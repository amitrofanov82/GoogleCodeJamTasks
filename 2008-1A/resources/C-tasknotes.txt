
Round 1A 2008
Problem C. Numbers
https://code.google.com/codejam/contest/32016/dashboard#s=p2

 find the last three digits before the decimal point for the number (3 + √5)^n.
 
 Простой вариант задачи решается довольно просто в лоб через BigDecimal. Но есть косяк с тем, чтобы положить достаточно точный корень пятерки
 в базу, от которой считаются степени. Стандартной точности дабла от Math.sqrt() достаточно только для решения этой задачи на первые 18 степеней.
 Нужный корень пятерки можно выдрать их какого калькулятора Винды, и тогда всё ок. 
 
 
 Универсальное же решение данной задачи очень математизированно, и нормальному программисту явно не под силу. 
 Даже полностью понять всю математику решеия прочитав анализ - задача непростая. Ниже алгоритм, основанный на этой математике: 
 
 Первая матконцепция - сопряженное число. 
 Получается (3 + √5)^n + (3 - √5)^n. Эта сумма будет целой, а второй множитель стремится к нулю. 
 
 Разложение через бином Ньютона дает устранение всех иррациональных частей из этой суммы. 
 
 Дальше можно вывести рекурсивную связь (как её вывести - это тоже ешё попробуй додумайся):
 
 a    = 3a + 5b     И   b    = 3b + a
  n+1     n    n         n+1     n   n 
   
И (3 + √5)^n = a + b *√5  = 2 * an  (!!!!)
                n   n

Так как α0 = 1 то (a0, b0) = (1, 0).


Всё операции сложения и умножения на целых числах могут проводится по модулю 1000, последние три цифры это не изменит. Nj  Это и даст ответ.   


Имеющееся в срц решение решает поставленную задачу итеративно находя ответ за 2млрд итераций.
Этого достаточно для решения, но занимает большее время, чем дается на отпраку ответа гуглом на соревнованиях.  
Это можно ускорить или использую факт наличия цикла. Или можно подготовить таблицы для больших значений.
Или использовать более продвинутую математику, предлагаемую в анализе.

INPUT:

T - test cases]
T lines - each is n
...

OUTPUT:
Case #i: answer

LIMITS:
1 ≤ T ≤ 100




















