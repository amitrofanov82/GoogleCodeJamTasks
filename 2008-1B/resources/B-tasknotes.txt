
Round 1B 2008
Problem B. Number Sets
https://code.google.com/codejam/contest/32017/dashboard#s=p1&a=1

Input
a b p

Limits:
1 <= A <= B <= 1012
B <= A + 1000000
2 <= P <= B

Для малого набора мы высчитывали для всех чисел из промежутка [a, b] все простые множители,
попутно сливая воедино все эти множества по всем возможным совпадениям. Для большого так не получится.

Для большого набора:
берем упорядоченный набор простых множителей, меньших чем B-A+1 (около 50тыс их будет для В=А+1000000)
Для каждого их них считаем сколько раз он встречается: (B-A+1)/pi +?1 в зависимости от остатка
Отбрасываем те, что встречаюся только 1 раз. Останется около 40тыс. в худшем случае.

Дальше непонятно. Гугл рекомендует следующие ссылки:
https://en.wikipedia.org/wiki/Disjoint-set_data_structure
https://en.wikipedia.org/wiki/Connected_component_(graph_theory)

Надо брать от меньшего фактора к большему все числа, им обладающие. Для 2, 3, 5 их будет довольно много,
но с каждым шагом все меньше и меньше. Это будет первый набор слитых множеств.

Дальше предлагается объединять их, по принципу как в компонентах связности графа или как Disjoint-set_data_structure.

С компонентами связности графов и  Disjoint-set_data_structure ещё стоит поработать, но в этой задаче на практике 
достаточно просто объеденить попарно, все пары множест содержащие общие элементы.

В общем всё работает, но производительность на грани. Для конкурса скорее всего не успется отправиться ответ.
Стоит хоть раз в 5 ещё ускорить. 
Слабое звено - проверка на наличие общего элемента и слияние больших множеств (занимает от полусекунды до 12 секунд).
Видимо можно как-то организовать множества и эти операции на них так, чтобы не надо было хранить все элементы, 
а только первый элемент и набор простых множителей.   














